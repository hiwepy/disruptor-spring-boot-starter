package com.lmax.disruptor.spring.boot;

import com.lmax.disruptor.BlockingWaitStrategy;
import com.lmax.disruptor.BusySpinWaitStrategy;
import com.lmax.disruptor.SleepingWaitStrategy;
import com.lmax.disruptor.YieldingWaitStrategy;

public enum WaitStrategy {

    /**
     * BlockingWaitStrategy 是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现
     **/
    BLOCKING_WAIT(new BlockingWaitStrategy()),
    /**
     * SleepingWaitStrategy 的性能表现跟BlockingWaitStrategy差不多，对CPU的消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景
     */
    SLEEPING_WAIT(new SleepingWaitStrategy()),
    /**
     * YieldingWaitStrategy是可以被用在低延迟系统中的两个策略之一，这种策略在减低系统延迟的同时也会增加CPU运算量。YieldingWaitStrategy策略会循环等待sequence增加到合适的值。循环中调用Thread.yield()允许其他准备好的线程执行。如果需要高性能而且事件消费者线程比逻辑内核少的时候，推荐使用YieldingWaitStrategy策略。例如：在开启超线程的时候。
     */
    YIELDING_WAIT(new YieldingWaitStrategy()),
    /**
     * BusySpinWaitStrategy是性能最高的等待策略，同时也是对部署环境要求最高的策略。这个性能最好用在事件处理线程比物理内核数目还要小的时候。例如：在禁用超线程技术的时候。
     */
    BUSYSPIN_WAIT(new BusySpinWaitStrategy());

    private com.lmax.disruptor.WaitStrategy waitStrategy;

    WaitStrategy(com.lmax.disruptor.WaitStrategy waitStrategy){
        this.waitStrategy = waitStrategy;
    }

    public com.lmax.disruptor.WaitStrategy get(){
        return waitStrategy;
    }

}
